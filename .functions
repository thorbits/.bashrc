#!/bin/bash
#
#	_______
#	\_   _/
#	  |_|horbits 
#
#	My bash config

#
# Description of the included funtions, () indicate required package(s).
#
# SYSTEM UPDATE
# update	: update your Arch, Debian or Fedora distro, simply type: update (debian req: nala)
#
# GENERAL COMMANDS
# calc		: simple calculator, usage: calc 2x2
# cdg		: change directory easily, to go up two directories for example usage: cdg 2 
# cdown		: colored countdown, usage: cdown 10 (figlet lolcat)
# cpg		: copy and go to the directory, usage: cpg source destination
# cppr		: copy file with a progress bar, usage: cppr source destination (rsync)
# cppv		: copy file with a progress bar, usage: cppv source destination (pv)
# cputemp	: display CPU temperature, Debian only, usage: get_temp (lm-Sensors)
# extract	: extract any archive(s) to a specified directory, usage: extract -d /path/to/dir archive1.tar.gz archive2.zip
# fds		: display total disk size of file(s) and sub-directories, usage: fds /path/to/dir
# mkcd		: create and go to the directory, usage: mkcd /path/to/dir
# mvg		: move and go to the directory, usage: mvg source destination
# openimg	: use feh to nicely view images, usage: openimage /path/to/image.jpg (feh)
# parabar	: display a progress bar, usage: parabar 1000 10 0.5 (parallel)
# pbar		: display a progress bar, usage: pbar 100
# right		: align input to the right of the screen, usage: yourcommand | right
# tmpd		: make a temporary directory and enter it, usage: 'tmpd' or 'tmpd mydir'
#
# SEARCH THE WEB
# ddg		: search DuckDuckGo and display in terminal, usage: ddg mysearch (links)
# mwiki		: query Wikipedia via console over DNS, usage: mwiki mysearch
# youplay	: play a youtube link in 1080p fullscreen, to quit press q, usage: youplay https://www.youtube.com/watch?v=example  (mpv yt-dlp)
#
# SCREENSAVERS
# matrix1-5	: matrix effects, usage: matrix1
# xlights	: colored lights, usage: xlights
#

#######################################################
#		UPDATE ARCH, DEBIAN OR FEDORA
#######################################################

update() { 
	local user_id=$(id -u)
	if [ "$user_id" -eq 0 ]; then
		case "$(uname -s)" in
			Linux*)
				if command -v nala &> /dev/null; then
					nala update && nala full-upgrade
				elif command -v pacman &> /dev/null; then
					pacman -Syyu --needed
				elif command -v dnf &> /dev/null; then
					dnf upgrade
				else
					echo "Unsupported Linux distribution"
				fi
				;;
		esac
	else
		case "$(uname -s)" in
			Linux*)
				if command -v sudo &> /dev/null; then
					if command -v nala &> /dev/null; then
						sudo nala update && sudo nala full-upgrade
					elif command -v pacman &> /dev/null; then
						sudo pacman -Syyu --needed
					elif command -v dnf &> /dev/null; then
						sudo dnf upgrade
					else
						echo "Unsupported Linux distribution"
					fi
				fi
				;;
			esac
	fi
}

#######################################################
#		GENERAL FUNCTIONS
#######################################################

####
calc() { 
	local result=""
	result="$(printf "scale=10;%s\\n" "$*" | bc --mathlib | tr -d '\\\n')"
	#						└─ default (when `--mathlib` is used) is 20

	if [[ "$result" == *.* ]]; then
		# improve the output for decimal numbers
		# add "0" for cases like ".5"
		# add "0" for cases like "-.5"
		# remove trailing zeros
		printf "%s" "$result" |
			sed -e 's/^\./0./'  \
			-e 's/^-\./-0./' \
			-e 's/0*$//;s/\.$//'
	else
		printf "%s" "$result"
	fi
	printf "\\n"
}

####
cdg() { 
	range=$(eval "echo '{1..$1}'")
	toPrint="'../%.0s' $range"
	printfToEval=$(echo "printf $toPrint")
	toCd=$(eval $printfToEval)
	eval "cd $toCd"
	pwd
}

####
cdown() { 
	N=$1 # Capture the argument as N
	# Start a while loop that continues until N is greater than 0
	while ((N-- > 0)); do
		# Display the current countdown number using figlet for ASCII art
		# and lolcat for colored output, then sleep for 1 second
		echo "$N" | figlet -c | lolcat && sleep 1
	done
}

####
cppr() { 
	# Check if rsync is available
	if ! command -v rsync &>/dev/null; then
		echo "Error: 'rsync' is not installed"
		return 1
	fi
	# Check the number of arguments
	if [[ "$#" -ne 2 ]]; then
		echo "Usage: cppb source_file destination_file"
		return 1
	fi
	# Run rsync with --progress option
	rsync --progress "$1" "$2"
}

####
cppv() { 
	if [ -z "$1" ] || [ -z "$2" ]; then
		echo "Usage: cppv source_file destination"
		return 1
	fi
	# Check if pv is available
	if ! command -v pv > /dev/null; then
		echo "Error: 'pv' is not installed"
		return 1
	fi
	# Use pv to display a progress bar during copy
	pv "$1" > "$2"
}

####
cpg() { 
	local source="$1"
	local destination="$2"
	if [ -d "$destination" ]; then
		cp "$source" "$destination" && cd "$destination" || return 1
	else
		cp "$source" "$destination" || return 1
	fi
}

####
cputemp() { 
	# Check if 'sensors' command is available
	if command -v sensors &>/dev/null; then
	# Extract CPU temperature using 'sensors'
	local cpu_temperature=$(sensors | grep "Core 0" | awk '{print $3}')
        # Check if temperature is not empty
        if [ -n "$cpu_temperature" ]; then
		echo "CPU Temperature: $cpu_temperature"
        else
		echo "Unable to retrieve CPU temperature."
        	fi
	else
        echo "Error: 'lm-sensors' is not installed"
	fi
}

####
extract() { 
	local dest_dir="."  # default destination directory
	while getopts ":d:" opt; do
		case $opt in
			d)
				dest_dir="$OPTARG"
				;;
			\?)
				echo "Invalid option: -$OPTARG" >&2
				return 1
				;;
		esac
	done

	shift $((OPTIND - 1))

	for archive in "$@"; do
		if [ -f "$archive" ]; then
			echo "Extracting '$archive' to '$dest_dir'..."
			case $archive in
				*.tar.bz2)   tar xjf "$archive" -C "$dest_dir" ;;
				*.tar.gz)    tar xzf "$archive" -C "$dest_dir" ;;
				*.bz2)       bunzip2 "$archive" ;;
				*.rar)       unrar x "$archive" "$dest_dir" ;;
				*.gz)        gunzip "$archive" ;;
				*.tar)       tar xvf "$archive" -C "$dest_dir" ;;
				*.tbz2)      tar xjf "$archive" -C "$dest_dir" ;;
				*.tgz)       tar xzf "$archive" -C "$dest_dir" ;;
				*.zip)       unzip "$archive" -d "$dest_dir" ;;
				*.Z)         uncompress "$archive" ;;
				*.7z)        7z x "$archive" -o"$dest_dir" ;;
				*.deb)       ar x "$archive" -C "$dest_dir" ;;
				*.tar.xz)    tar xf "$archive" -C "$dest_dir" ;;
				*.tar.zst)   unzstd "$archive" -d "$dest_dir" ;;
				*)
					echo "Unsupported archive format: '$archive'" >&2
					continue
					;;
			esac
			echo "Extraction of '$archive' completed successfully."
		else
			echo "'$archive' is not a valid file!"
		fi
	done
}

####
fds() { 
	local arg
	if du -b /dev/null > /dev/null 2>&1; then
		arg=-sbh
	else
		arg=-sh
	fi
	if [[ -n "$@" ]]; then
		du $arg -- "$@" | sort -k2
	else
		du $arg -- .[^.]* * | sort -k2
	fi
}

####
mkcd(){ NAME=$1; mkdir -p "$NAME"; cd "$NAME"; }

####
mvg() { 
	local source="$1"
	local destination="$2"
	if [ -d "$destination" ]; then
		mv "$source" "$destination" && cd "$destination" || return 1
	else
		mv "$source" "$destination" || return 1
	fi
}

####
openimg() { 
	local types='*.jpg *.JPG *.png *.PNG *.gif *.GIF *.jpeg *.JPEG'

	cd "$(dirname "$1")" || exit
	local file
	file=$(basename "$1")

	feh -q "$types" --auto-zoom \
		--sort filename --borderless \
		--scale-down --draw-filename \
		--image-bg black \
		--start-at "$file"
}

####
parabar() { 
	local range="$1"
	local jobs="$2"
	local sleeptime="${3:-1}"  # Default sleep duration is 1 second
	seq "$range" | parallel -j"$jobs" --bar 'echo {}; sleep '"$sleeptime"'; clear'
}

####
pbar() { 
	local duration
	local columns
	local space_available
	local fit_to_screen
	local space_reserved

	space_reserved=6   # reserved for % value
	duration=${1}
	columns=$(tput cols)
	space_available=$(( columns-space_reserved ))

	if (( duration < space_available )); then 
		fit_to_screen=1;
	else 
		fit_to_screen=$(( duration / space_available ));
		fit_to_screen=$((fit_to_screen+1));
	fi

	pbar_done() { for ((done=0; done<(elapsed / fit_to_screen) ; done=done+1 )); do printf ">"; done }
	pbar_remain() { for (( remain=(elapsed/fit_to_screen) ; remain<(duration/fit_to_screen) ; remain=remain+1 )); do printf " "; done }
	pbar_percent() { printf "| %s%%" $(( ((elapsed)*100)/(duration)*100/100 )) | lolcat; }
	pbar_clean() { printf "\r"; }

	for (( elapsed=1; elapsed<=duration; elapsed=elapsed+1 )); do
		pbar_done; pbar_remain; pbar_percent
		sleep 1
		pbar_clean
	done
	pbar_clean
}

####
right() { 
	local input="$(cat -)"
	local max_length=$(echo -e "$input" | wc -L)
	while read -r line; do
		printf "%*s%s\n" "$((max_length - ${#line}))" "" "$line"
	done <<< "$input"
}

####
tmpd() { 
	local dir
	if [ $# -eq 0 ]; then
		dir=$(mktemp -d)
	else
		dir=$(mktemp -d -t "${1}.XXXXXXXXXX")
	fi
	cd "$dir" || exit
}

#######################################################
#		SEARCH
#######################################################

####
ddg() { 
	ARGS="$@"					# Store all arguments as a single string in the variable ARGS
	links "https://www.duckduckgo.com/?q=${ARGS}"	# Open DuckDuckGo with the query using 'links'
}

####
mwiki() { 
	# Replace spaces with underscores in the input argument
	modified_input=$(echo "$*" | sed 's| |_|g')
	# Use host to query for the article
	host -t txt "${modified_input}.wp.dg.cx"
}

####
rnews() { 
links $( a=( $( lynx -dump -listonly "https://radiocanadamini.ca/a-la-une/articles/" | grep -Eo "(http|https)://[a-zA-Z0-9./?=_-]*" | grep -v "radiocanadamini.ca/a-la-une/articles/" | sort | uniq ) ) ; amax=${#a[@]} ; n=$(( `date '+%s'` % $amax )) ; echo ${a[n]} )
}

####
youplay() { 
	local video_id="$1"
	mpv --no-config --fs --vo=drm --no-audio --ytdl-format='bestvideo[width<=1920][height<=1080]+bestaudio/best' "$video_id"
}

#######################################################
#		SCREENSAVERS
#######################################################

####
matrix1() { 
	echo -e "\e[32m"  # Set text color to green
	while :; do
		for _ in {1..50}; do  # Repeat the animation 50 times for each row
			for _ in {1..80}; do
				r=$((RANDOM % 2))
				if [[ $((RANDOM % 5)) == 1 ]]; then
					if [[ $((RANDOM % 4)) == 1 ]]; then
						v+="\e[1m $r "  # Bold characters
					else
						v+="\e[2m $r "  # Dim characters
					fi
				else
					v+=" "
				fi
			done
			echo -e "$v"
			v=""
		done
		sleep 0.1  # Adjust for sleep duration
	done
}

####
matrix2() { 
	perl -MTerm::ReadKey -e '
		use Term::ANSIColor;
		$|++;
		ReadMode 4;  # Turn off buffering

		while (1) {
			print color("green"), " " x (rand(35) + 1), int(rand(2)), color("reset");
			select(undef, undef, undef, 0.005);  # Adjust for sleep duration

			if (defined($key = ReadKey(-1))) {
				if (ord($key) == 27) {
					last;
				}
			}
		}

		ReadMode 0;  # Restore original terminal mode
		print "\n";  # Print a newline to clear any residual text
	'
}

####
matrix3() { 
	clear
	echo -ne "\e[32m"
	while true
	do
		echo -ne "\e[$(($RANDOM % 2 + 1))m"
		tr -c "[:print:]" " " < /dev/urandom | dd count=1 bs=50 2> /dev/null
	# Check for ESC key press
	read -n 1 -s -t 0.1 key
	if [[ $key == $'\e' ]]; then
		clear
		break
	fi
	done
}

####
matrix4() { 
	clear
	while true; do
		COL=$((RANDOM % $(tput cols)))
		for ((i = 0; i < COL; i++)); do
			tput cup $i $COL
			echo -e "\033[0;32m" $(cat /dev/urandom | head -1 | cut -c1-1) 2>/dev/null
		done
		# Check for ESC key press
		read -n 1 -s -t 0.1 key
		if [[ $key == $'\e' ]]; then
			clear
			break
		fi

		sleep 0.2  # Adjust to the desired speed
	done
}

####
matrix5() { 
	tr -c "[:digit:]" " " < /dev/urandom | dd cbs=$COLUMNS conv=unblock | GREP_COLOR="1;32" grep --color "[^ ]"
}

####
xlights() { 
	clear
	while :
	do
		echo -ne "\033[$((1+RANDOM%LINES));$((1+RANDOM%COLUMNS))H\033[$((RANDOM%2));3$((RANDOM%8))m$((RANDOM%10))"
		sleep 0.1
	done
}
